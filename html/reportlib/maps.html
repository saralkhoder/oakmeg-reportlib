<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>reportlib.maps API documentation</title>
<meta name="description" content="Module for creating Atom maps" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>reportlib.maps</code></h1>
</header>
<section id="section-intro">
<p>Module for creating Atom maps</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Module for creating Atom maps&#34;&#34;&#34;
import io
from pathlib import Path

from enum import Enum
import pandas as pd
import numpy as np
import pygeohash
from PIL import Image
import folium
from folium import plugins
from branca import colormap as cm

from reportlib.utils import Colors


class Tile(Enum):
    TERRAIN = &#34;Stamen Terrain&#34;
    STREETS = &#34;https://api.mapbox.com/styles/v1/gaspardfeuvray/ckpofztgc08ys17mlpwabqxhz/tiles/256/{z}/{x}/{y}@2x?\
access_token=pk.eyJ1IjoiZ2FzcGFyZGZldXZyYXkiLCJhIjoiY2p2YzdhMHZzMWZyMzN5bWo3dTUwY2UxcSJ9.MwgCkS-8xqvM9wjQI-vjgw&#34;
    MONOCHROME = &#34;https://api.mapbox.com/styles/v1/gaspardfeuvray/ckrap3uup0c9717o09tntz4or/tiles/256/{z}/{x}/{y}@2x?\
access_token=pk.eyJ1IjoiZ2FzcGFyZGZldXZyYXkiLCJhIjoiY2p2YzdhMHZzMWZyMzN5bWo3dTUwY2UxcSJ9.MwgCkS-8xqvM9wjQI-vjgw&#34;


class _Palette(Enum):
    AOI = Colors.BLUE.value


class AtomMap:
    &#34;&#34;&#34;
    A map object with multiple layers for displaying aois, points, geojson, chloropleth, ...
    Choose the base style from `reportlib.maps.Tile`

    Returns:
        A pandas DataFrame with the query result
    &#34;&#34;&#34;

    def __init__(self, tile: Tile):
        self.fmap = create_map(tile)
        self.layers = []
        self.bounds = {&#34;sw&#34;: [], &#34;ne&#34;: []}

        # Init map
        self.fmap.add_child(folium.LayerControl())
        self.fmap.add_child(folium.plugins.MeasureControl(primary_length_unit=&#34;meters&#34;))

    def _update_bounds(self, lat: list, lon: list) -&gt; object:
        &#34;&#34;&#34;
        Update SW/NE bounds to include new geodata

        Returns:
            self, for chaining
        &#34;&#34;&#34;

        def update_bound(prop, func):
            if self.bounds[prop]:
                self.bounds[prop] = [
                    func(self.bounds[prop][0], func(list(lat))),
                    func(self.bounds[prop][1], func(list(lon))),
                ]
            else:
                self.bounds[prop] = [func(list(lat)), func(list(lon))]

        update_bound(&#34;sw&#34;, min)
        update_bound(&#34;ne&#34;, max)

    def add_aois(self, aois: pd.DataFrame) -&gt; None:
        &#34;&#34;&#34;
        Add a layer with AOIs

        Args:
            aois (DataFrame): The aois to display on the map
        Returns:
            self, for chaining
        &#34;&#34;&#34;
        for index, aoi in aois.iterrows():
            popup = folium.Popup(
                html=f&#34;&lt;b&gt;{aoi[&#39;name&#39;]}&lt;/b&gt;&lt;/br&gt;&#34;,
                show=False,
                sticky=True,
                max_width=500,
            )
            folium.Circle(
                [aoi[&#34;latitude&#34;], aoi[&#34;longitude&#34;]],
                radius=aoi[&#34;radius_km&#34;] * 1000,
                popup=popup,
                fill_color=_Palette.AOI.value,
                color=_Palette.AOI.value,
                opacity=0.3,
            ).add_to(self.fmap)

        self._update_bounds(aois[&#34;latitude&#34;], aois[&#34;longitude&#34;])
        return self  # for serialisation

    def add_aois_perf(
        self,
        df,
    ):
        &#34;&#34;&#34;
        Add a layer showing performance per AOI, color represents clickthrough rate and size impressions volume

        Args:
            df (DataFrame): The performance data, must have a geohash column to locate the aois
        Returns:
            self, for chaining
        &#34;&#34;&#34;
        # Group and compute performance
        perf = df.groupby(&#34;geohash&#34;, as_index=False).agg(
            {&#34;impressions&#34;: &#34;sum&#34;, &#34;clicks&#34;: &#34;sum&#34;, &#34;geohash&#34;: &#34;first&#34;}
        )
        perf[&#34;ctr&#34;] = perf[&#34;clicks&#34;] / perf[&#34;impressions&#34;]
        perf[&#34;ctr_perc&#34;] = perf[&#34;ctr&#34;] * 100

        minctr = perf[&#34;ctr_perc&#34;].min()
        maxctr = perf[&#34;ctr_perc&#34;].max()

        # Print ctr and impressions range
        print(&#34;ctr:&#34;, minctr, &#34;-&#34;, maxctr)
        print(&#34;impressions:&#34;, perf[&#34;impressions&#34;].min(), &#34;-&#34;, perf[&#34;impressions&#34;].max())

        def linmap(v, mn, mx, mn_to=0, mx_to=1):
            return (v - mn) / (mx - mn) * (mx_to - mn_to) + mn_to

        colormap = cm.LinearColormap(
            colors=[&#34;#F5A331&#34;, &#34;#F5E214&#34;, &#34;#35CC3F&#34;],
            index=[minctr - 0.15, (minctr - 0.15 + maxctr) / 2, maxctr],
            vmin=minctr - 0.15,
            vmax=maxctr,
        )

        # Creates the marker for an AOI
        def marker(geohash, size, intensity):
            return folium.CircleMarker(
                pygeohash.decode(geohash),
                radius=size,
                # color=matplotlib.colors.rgb2hex(colormap(intensity)),
                # fill_color=matplotlib.colors.rgb2hex(colormap(intensity)),
                color=colormap(intensity),
                fill_color=colormap(intensity),
                opacity=1,
                fill_opacity=0.4,
            )

        for _, aoi in perf.iterrows():
            size = linmap(
                aoi[&#34;impressions&#34;],
                perf[&#34;impressions&#34;].min(),
                perf[&#34;impressions&#34;].max(),
                mn_to=10,
                mx_to=25,
            )
            intensity = aoi[&#34;ctr_perc&#34;]
            self.fmap.add_child(marker(aoi[&#34;geohash&#34;], size, intensity))

        # Update map boundaries
        aoi_centroids = np.array(
            list(perf[&#34;geohash&#34;].apply(lambda g: pygeohash.decode(g)))
        )
        self._update_bounds(aoi_centroids[:, 0], aoi_centroids[:, 1])
        return self

    def show(self) -&gt; object:
        &#34;&#34;&#34;
        Display the map

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        self.fmap.fit_bounds([self.bounds[&#34;sw&#34;], self.bounds[&#34;ne&#34;]])
        return self.fmap

    def save(self, to: str) -&gt; object:
        &#34;&#34;&#34;
        Save the map in a generated folder

        Args:
            to (str): the new file name, without extension

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        _save_map(self.fmap, to=to)
        return self.fmap


def create_map(tile: Tile) -&gt; folium.Map:
    return folium.Map(tiles=None).add_child(
        folium.TileLayer(tile.value, name=&#34;base_map&#34;, attr=&#34;atom&#34;)
    )


def _save_map(fmap: folium.Map, to: str) -&gt; None:
    &#34;&#34;&#34;
    Save the map in a generated folder. Note that the process takes ~5 seconds

    Args:
        fmap (folium.Map): the map to save
        to (str): *optional*, the new file name, without extension

    Returns:
        The created folium map
    &#34;&#34;&#34;
    Path(&#34;generated&#34;).mkdir(parents=True, exist_ok=True)
    img_data = fmap._to_png(5)
    img = Image.open(io.BytesIO(img_data))
    img.save(&#34;generated/&#34; + to + &#34;.png&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="reportlib.maps.create_map"><code class="name flex">
<span>def <span class="ident">create_map</span></span>(<span>tile: <a title="reportlib.maps.Tile" href="#reportlib.maps.Tile">Tile</a>) ‑> folium.folium.Map</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_map(tile: Tile) -&gt; folium.Map:
    return folium.Map(tiles=None).add_child(
        folium.TileLayer(tile.value, name=&#34;base_map&#34;, attr=&#34;atom&#34;)
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="reportlib.maps.AtomMap"><code class="flex name class">
<span>class <span class="ident">AtomMap</span></span>
<span>(</span><span>tile: <a title="reportlib.maps.Tile" href="#reportlib.maps.Tile">Tile</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A map object with multiple layers for displaying aois, points, geojson, chloropleth, &hellip;
Choose the base style from <code><a title="reportlib.maps.Tile" href="#reportlib.maps.Tile">Tile</a></code></p>
<h2 id="returns">Returns</h2>
<p>A pandas DataFrame with the query result</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AtomMap:
    &#34;&#34;&#34;
    A map object with multiple layers for displaying aois, points, geojson, chloropleth, ...
    Choose the base style from `reportlib.maps.Tile`

    Returns:
        A pandas DataFrame with the query result
    &#34;&#34;&#34;

    def __init__(self, tile: Tile):
        self.fmap = create_map(tile)
        self.layers = []
        self.bounds = {&#34;sw&#34;: [], &#34;ne&#34;: []}

        # Init map
        self.fmap.add_child(folium.LayerControl())
        self.fmap.add_child(folium.plugins.MeasureControl(primary_length_unit=&#34;meters&#34;))

    def _update_bounds(self, lat: list, lon: list) -&gt; object:
        &#34;&#34;&#34;
        Update SW/NE bounds to include new geodata

        Returns:
            self, for chaining
        &#34;&#34;&#34;

        def update_bound(prop, func):
            if self.bounds[prop]:
                self.bounds[prop] = [
                    func(self.bounds[prop][0], func(list(lat))),
                    func(self.bounds[prop][1], func(list(lon))),
                ]
            else:
                self.bounds[prop] = [func(list(lat)), func(list(lon))]

        update_bound(&#34;sw&#34;, min)
        update_bound(&#34;ne&#34;, max)

    def add_aois(self, aois: pd.DataFrame) -&gt; None:
        &#34;&#34;&#34;
        Add a layer with AOIs

        Args:
            aois (DataFrame): The aois to display on the map
        Returns:
            self, for chaining
        &#34;&#34;&#34;
        for index, aoi in aois.iterrows():
            popup = folium.Popup(
                html=f&#34;&lt;b&gt;{aoi[&#39;name&#39;]}&lt;/b&gt;&lt;/br&gt;&#34;,
                show=False,
                sticky=True,
                max_width=500,
            )
            folium.Circle(
                [aoi[&#34;latitude&#34;], aoi[&#34;longitude&#34;]],
                radius=aoi[&#34;radius_km&#34;] * 1000,
                popup=popup,
                fill_color=_Palette.AOI.value,
                color=_Palette.AOI.value,
                opacity=0.3,
            ).add_to(self.fmap)

        self._update_bounds(aois[&#34;latitude&#34;], aois[&#34;longitude&#34;])
        return self  # for serialisation

    def add_aois_perf(
        self,
        df,
    ):
        &#34;&#34;&#34;
        Add a layer showing performance per AOI, color represents clickthrough rate and size impressions volume

        Args:
            df (DataFrame): The performance data, must have a geohash column to locate the aois
        Returns:
            self, for chaining
        &#34;&#34;&#34;
        # Group and compute performance
        perf = df.groupby(&#34;geohash&#34;, as_index=False).agg(
            {&#34;impressions&#34;: &#34;sum&#34;, &#34;clicks&#34;: &#34;sum&#34;, &#34;geohash&#34;: &#34;first&#34;}
        )
        perf[&#34;ctr&#34;] = perf[&#34;clicks&#34;] / perf[&#34;impressions&#34;]
        perf[&#34;ctr_perc&#34;] = perf[&#34;ctr&#34;] * 100

        minctr = perf[&#34;ctr_perc&#34;].min()
        maxctr = perf[&#34;ctr_perc&#34;].max()

        # Print ctr and impressions range
        print(&#34;ctr:&#34;, minctr, &#34;-&#34;, maxctr)
        print(&#34;impressions:&#34;, perf[&#34;impressions&#34;].min(), &#34;-&#34;, perf[&#34;impressions&#34;].max())

        def linmap(v, mn, mx, mn_to=0, mx_to=1):
            return (v - mn) / (mx - mn) * (mx_to - mn_to) + mn_to

        colormap = cm.LinearColormap(
            colors=[&#34;#F5A331&#34;, &#34;#F5E214&#34;, &#34;#35CC3F&#34;],
            index=[minctr - 0.15, (minctr - 0.15 + maxctr) / 2, maxctr],
            vmin=minctr - 0.15,
            vmax=maxctr,
        )

        # Creates the marker for an AOI
        def marker(geohash, size, intensity):
            return folium.CircleMarker(
                pygeohash.decode(geohash),
                radius=size,
                # color=matplotlib.colors.rgb2hex(colormap(intensity)),
                # fill_color=matplotlib.colors.rgb2hex(colormap(intensity)),
                color=colormap(intensity),
                fill_color=colormap(intensity),
                opacity=1,
                fill_opacity=0.4,
            )

        for _, aoi in perf.iterrows():
            size = linmap(
                aoi[&#34;impressions&#34;],
                perf[&#34;impressions&#34;].min(),
                perf[&#34;impressions&#34;].max(),
                mn_to=10,
                mx_to=25,
            )
            intensity = aoi[&#34;ctr_perc&#34;]
            self.fmap.add_child(marker(aoi[&#34;geohash&#34;], size, intensity))

        # Update map boundaries
        aoi_centroids = np.array(
            list(perf[&#34;geohash&#34;].apply(lambda g: pygeohash.decode(g)))
        )
        self._update_bounds(aoi_centroids[:, 0], aoi_centroids[:, 1])
        return self

    def show(self) -&gt; object:
        &#34;&#34;&#34;
        Display the map

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        self.fmap.fit_bounds([self.bounds[&#34;sw&#34;], self.bounds[&#34;ne&#34;]])
        return self.fmap

    def save(self, to: str) -&gt; object:
        &#34;&#34;&#34;
        Save the map in a generated folder

        Args:
            to (str): the new file name, without extension

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        _save_map(self.fmap, to=to)
        return self.fmap</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="reportlib.maps.AtomMap.add_aois"><code class="name flex">
<span>def <span class="ident">add_aois</span></span>(<span>self, aois: pandas.core.frame.DataFrame) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a layer with AOIs</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>aois</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>The aois to display on the map</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>self, for chaining</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_aois(self, aois: pd.DataFrame) -&gt; None:
    &#34;&#34;&#34;
    Add a layer with AOIs

    Args:
        aois (DataFrame): The aois to display on the map
    Returns:
        self, for chaining
    &#34;&#34;&#34;
    for index, aoi in aois.iterrows():
        popup = folium.Popup(
            html=f&#34;&lt;b&gt;{aoi[&#39;name&#39;]}&lt;/b&gt;&lt;/br&gt;&#34;,
            show=False,
            sticky=True,
            max_width=500,
        )
        folium.Circle(
            [aoi[&#34;latitude&#34;], aoi[&#34;longitude&#34;]],
            radius=aoi[&#34;radius_km&#34;] * 1000,
            popup=popup,
            fill_color=_Palette.AOI.value,
            color=_Palette.AOI.value,
            opacity=0.3,
        ).add_to(self.fmap)

    self._update_bounds(aois[&#34;latitude&#34;], aois[&#34;longitude&#34;])
    return self  # for serialisation</code></pre>
</details>
</dd>
<dt id="reportlib.maps.AtomMap.add_aois_perf"><code class="name flex">
<span>def <span class="ident">add_aois_perf</span></span>(<span>self, df)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a layer showing performance per AOI, color represents clickthrough rate and size impressions volume</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>The performance data, must have a geohash column to locate the aois</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>self, for chaining</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_aois_perf(
    self,
    df,
):
    &#34;&#34;&#34;
    Add a layer showing performance per AOI, color represents clickthrough rate and size impressions volume

    Args:
        df (DataFrame): The performance data, must have a geohash column to locate the aois
    Returns:
        self, for chaining
    &#34;&#34;&#34;
    # Group and compute performance
    perf = df.groupby(&#34;geohash&#34;, as_index=False).agg(
        {&#34;impressions&#34;: &#34;sum&#34;, &#34;clicks&#34;: &#34;sum&#34;, &#34;geohash&#34;: &#34;first&#34;}
    )
    perf[&#34;ctr&#34;] = perf[&#34;clicks&#34;] / perf[&#34;impressions&#34;]
    perf[&#34;ctr_perc&#34;] = perf[&#34;ctr&#34;] * 100

    minctr = perf[&#34;ctr_perc&#34;].min()
    maxctr = perf[&#34;ctr_perc&#34;].max()

    # Print ctr and impressions range
    print(&#34;ctr:&#34;, minctr, &#34;-&#34;, maxctr)
    print(&#34;impressions:&#34;, perf[&#34;impressions&#34;].min(), &#34;-&#34;, perf[&#34;impressions&#34;].max())

    def linmap(v, mn, mx, mn_to=0, mx_to=1):
        return (v - mn) / (mx - mn) * (mx_to - mn_to) + mn_to

    colormap = cm.LinearColormap(
        colors=[&#34;#F5A331&#34;, &#34;#F5E214&#34;, &#34;#35CC3F&#34;],
        index=[minctr - 0.15, (minctr - 0.15 + maxctr) / 2, maxctr],
        vmin=minctr - 0.15,
        vmax=maxctr,
    )

    # Creates the marker for an AOI
    def marker(geohash, size, intensity):
        return folium.CircleMarker(
            pygeohash.decode(geohash),
            radius=size,
            # color=matplotlib.colors.rgb2hex(colormap(intensity)),
            # fill_color=matplotlib.colors.rgb2hex(colormap(intensity)),
            color=colormap(intensity),
            fill_color=colormap(intensity),
            opacity=1,
            fill_opacity=0.4,
        )

    for _, aoi in perf.iterrows():
        size = linmap(
            aoi[&#34;impressions&#34;],
            perf[&#34;impressions&#34;].min(),
            perf[&#34;impressions&#34;].max(),
            mn_to=10,
            mx_to=25,
        )
        intensity = aoi[&#34;ctr_perc&#34;]
        self.fmap.add_child(marker(aoi[&#34;geohash&#34;], size, intensity))

    # Update map boundaries
    aoi_centroids = np.array(
        list(perf[&#34;geohash&#34;].apply(lambda g: pygeohash.decode(g)))
    )
    self._update_bounds(aoi_centroids[:, 0], aoi_centroids[:, 1])
    return self</code></pre>
</details>
</dd>
<dt id="reportlib.maps.AtomMap.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, to: str) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Save the map in a generated folder</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>to</code></strong> :&ensp;<code>str</code></dt>
<dd>the new file name, without extension</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>self, for chaining</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, to: str) -&gt; object:
    &#34;&#34;&#34;
    Save the map in a generated folder

    Args:
        to (str): the new file name, without extension

    Returns:
        self, for chaining
    &#34;&#34;&#34;
    _save_map(self.fmap, to=to)
    return self.fmap</code></pre>
</details>
</dd>
<dt id="reportlib.maps.AtomMap.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Display the map</p>
<h2 id="returns">Returns</h2>
<p>self, for chaining</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self) -&gt; object:
    &#34;&#34;&#34;
    Display the map

    Returns:
        self, for chaining
    &#34;&#34;&#34;
    self.fmap.fit_bounds([self.bounds[&#34;sw&#34;], self.bounds[&#34;ne&#34;]])
    return self.fmap</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="reportlib.maps.Tile"><code class="flex name class">
<span>class <span class="ident">Tile</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tile(Enum):
    TERRAIN = &#34;Stamen Terrain&#34;
    STREETS = &#34;https://api.mapbox.com/styles/v1/gaspardfeuvray/ckpofztgc08ys17mlpwabqxhz/tiles/256/{z}/{x}/{y}@2x?\
access_token=pk.eyJ1IjoiZ2FzcGFyZGZldXZyYXkiLCJhIjoiY2p2YzdhMHZzMWZyMzN5bWo3dTUwY2UxcSJ9.MwgCkS-8xqvM9wjQI-vjgw&#34;
    MONOCHROME = &#34;https://api.mapbox.com/styles/v1/gaspardfeuvray/ckrap3uup0c9717o09tntz4or/tiles/256/{z}/{x}/{y}@2x?\
access_token=pk.eyJ1IjoiZ2FzcGFyZGZldXZyYXkiLCJhIjoiY2p2YzdhMHZzMWZyMzN5bWo3dTUwY2UxcSJ9.MwgCkS-8xqvM9wjQI-vjgw&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="reportlib.maps.Tile.MONOCHROME"><code class="name">var <span class="ident">MONOCHROME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="reportlib.maps.Tile.STREETS"><code class="name">var <span class="ident">STREETS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="reportlib.maps.Tile.TERRAIN"><code class="name">var <span class="ident">TERRAIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="reportlib" href="index.html">reportlib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="reportlib.maps.create_map" href="#reportlib.maps.create_map">create_map</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="reportlib.maps.AtomMap" href="#reportlib.maps.AtomMap">AtomMap</a></code></h4>
<ul class="">
<li><code><a title="reportlib.maps.AtomMap.add_aois" href="#reportlib.maps.AtomMap.add_aois">add_aois</a></code></li>
<li><code><a title="reportlib.maps.AtomMap.add_aois_perf" href="#reportlib.maps.AtomMap.add_aois_perf">add_aois_perf</a></code></li>
<li><code><a title="reportlib.maps.AtomMap.save" href="#reportlib.maps.AtomMap.save">save</a></code></li>
<li><code><a title="reportlib.maps.AtomMap.show" href="#reportlib.maps.AtomMap.show">show</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="reportlib.maps.Tile" href="#reportlib.maps.Tile">Tile</a></code></h4>
<ul class="">
<li><code><a title="reportlib.maps.Tile.MONOCHROME" href="#reportlib.maps.Tile.MONOCHROME">MONOCHROME</a></code></li>
<li><code><a title="reportlib.maps.Tile.STREETS" href="#reportlib.maps.Tile.STREETS">STREETS</a></code></li>
<li><code><a title="reportlib.maps.Tile.TERRAIN" href="#reportlib.maps.Tile.TERRAIN">TERRAIN</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>