<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>reportlib.maps API documentation</title>
<meta name="description" content="Module for creating Atom maps" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>reportlib.maps</code></h1>
</header>
<section id="section-intro">
<p>Module for creating Atom maps</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Module for creating Atom maps&#34;&#34;&#34;
import io
import json
from pathlib import Path
from enum import Enum

import pandas as pd
import numpy as np
import pygeohash
import geojson
from PIL import Image
import folium
from folium import plugins
from branca import colormap as cm

from reportlib.utils import Color


class Tile(Enum):
    TERRAIN = &#34;Stamen Terrain&#34;
    STREETS = &#34;https://api.mapbox.com/styles/v1/gaspardfeuvray/ckpofztgc08ys17mlpwabqxhz/tiles/256/{z}/{x}/{y}@2x?\
access_token=pk.eyJ1IjoiZ2FzcGFyZGZldXZyYXkiLCJhIjoiY2p2YzdhMHZzMWZyMzN5bWo3dTUwY2UxcSJ9.MwgCkS-8xqvM9wjQI-vjgw&#34;
    MONOCHROME = &#34;https://api.mapbox.com/styles/v1/gaspardfeuvray/ckrap3uup0c9717o09tntz4or/tiles/256/{z}/{x}/{y}@2x?\
access_token=pk.eyJ1IjoiZ2FzcGFyZGZldXZyYXkiLCJhIjoiY2p2YzdhMHZzMWZyMzN5bWo3dTUwY2UxcSJ9.MwgCkS-8xqvM9wjQI-vjgw&#34;


class _Palette(Enum):
    AOI = Color.BLUE.value


class AtomMap:
    &#34;&#34;&#34;
    A map object with multiple layers for displaying aois, points, geojson, chloropleth, ...
    Choose the base style from `reportlib.maps.Tile`

    Returns:
        A pandas DataFrame with the query result
    &#34;&#34;&#34;

    def __init__(self, tile: Tile):
        self.fmap = _create_map(tile)
        self.layers = []
        self.bounds = {&#34;sw&#34;: [], &#34;ne&#34;: []}

        # Init map
        # self.fmap.add_child(folium.LayerControl())

    def _update_bounds(self, lat: list, lon: list) -&gt; object:
        &#34;&#34;&#34;
        Update SW/NE bounds to include new geodata

        Returns:
            self, for chaining
        &#34;&#34;&#34;

        def update_bound(prop, func):
            if self.bounds[prop]:
                self.bounds[prop] = [
                    func(self.bounds[prop][0], func(list(lat))),
                    func(self.bounds[prop][1], func(list(lon))),
                ]
            else:
                self.bounds[prop] = [func(list(lat)), func(list(lon))]

        update_bound(&#34;sw&#34;, min)
        update_bound(&#34;ne&#34;, max)

    def add_aois(self, aois: pd.DataFrame) -&gt; None:
        &#34;&#34;&#34;
        Add a layer with AOIs

        Args:
            aois (DataFrame): The aois to display on the map

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        for index, aoi in aois.iterrows():
            popup = folium.Popup(
                html=f&#34;&lt;b&gt;{aoi[&#39;name&#39;]}&lt;/b&gt;&lt;/br&gt;&#34;,
                show=False,
                sticky=True,
                max_width=500,
            )
            folium.Circle(
                [aoi[&#34;latitude&#34;], aoi[&#34;longitude&#34;]],
                radius=aoi[&#34;radius_km&#34;] * 1000,
                popup=popup,
                fill_color=_Palette.AOI.value,
                color=_Palette.AOI.value,
                opacity=0.3,
            ).add_to(self.fmap)

        self._update_bounds(aois[&#34;latitude&#34;], aois[&#34;longitude&#34;])
        return self  # for serialisation

    # TODO: make this work consistently, edit parameters
    def add_aois_perf(
        self,
        df: pd.DataFrame,
        ctr_color_offset: int = 0,
        markers_size_range: list = [10, 25],
    ):
        &#34;&#34;&#34;
        Add a layer showing performance per AOI, color represents clickthrough rate and size impressions volume

        Args:
            df (DataFrame): The performance data, must have a geohash column to locate the aois
            ctr_color_offset (int): *optional*, by how much to offset the lower bound of the ctr range, will make
            all markers greener
            markers_size_range ([int, int]): *optional*, the range of marker size

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        # Group and compute performance
        perf = df.groupby(&#34;geohash&#34;, as_index=False).agg(
            {&#34;impressions&#34;: &#34;sum&#34;, &#34;clicks&#34;: &#34;sum&#34;, &#34;geohash&#34;: &#34;first&#34;}
        )
        perf[&#34;ctr&#34;] = perf[&#34;clicks&#34;] / perf[&#34;impressions&#34;]
        perf[&#34;ctr_perc&#34;] = perf[&#34;ctr&#34;] * 100

        minctr = perf[&#34;ctr_perc&#34;].min()
        maxctr = perf[&#34;ctr_perc&#34;].max()

        # Print ctr and impressions range
        print(&#34;ctr range for color:&#34;, minctr - ctr_color_offset, &#34;-&#34;, maxctr)
        print(
            &#34;impressions range:&#34;,
            perf[&#34;impressions&#34;].min(),
            &#34;-&#34;,
            perf[&#34;impressions&#34;].max(),
        )

        def linmap(v, mn, mx, mn_to=0, mx_to=1):
            return (v - mn) / (mx - mn) * (mx_to - mn_to) + mn_to

        colormap = cm.LinearColormap(
            colors=[&#34;#F5A331&#34;, &#34;#F5E214&#34;, &#34;#35CC3F&#34;],
            index=[
                minctr - ctr_color_offset,
                (minctr - ctr_color_offset + maxctr) / 2,
                maxctr,
            ],
            vmin=minctr - ctr_color_offset,
            vmax=maxctr,
        )

        # Creates the marker for an AOI
        def marker(geohash, size, intensity):
            return folium.CircleMarker(
                pygeohash.decode(geohash),
                radius=size,
                # color=matplotlib.colors.rgb2hex(colormap(intensity)),
                # fill_color=matplotlib.colors.rgb2hex(colormap(intensity)),
                color=colormap(intensity),
                fill_color=colormap(intensity),
                opacity=1,
                fill_opacity=0.4,
            )

        for _, aoi in perf.iterrows():
            size = linmap(
                aoi[&#34;impressions&#34;],
                perf[&#34;impressions&#34;].min(),
                perf[&#34;impressions&#34;].max(),
                mn_to=markers_size_range[0],
                mx_to=markers_size_range[1],
            )
            intensity = aoi[&#34;ctr_perc&#34;]
            self.fmap.add_child(marker(aoi[&#34;geohash&#34;], size, intensity))

        # Update map boundaries
        aoi_centroids = np.array(
            list(perf[&#34;geohash&#34;].apply(lambda g: pygeohash.decode(g)))
        )
        self._update_bounds(aoi_centroids[:, 0], aoi_centroids[:, 1])
        return self

    def add_points(
        self,
        df: pd.DataFrame,
        lat: str = &#34;latitude&#34;,
        lon: str = &#34;longitude&#34;,
        color: Color = Color.BLUE,
        rad: int = 1,
        plot_max: int = 20000,
    ):
        &#34;&#34;&#34;
        Add a layer showing points from a dataframe

        Args:
            df (DataFrame): The input data
            lat (str): *optional*, name of the column containing latitudes
            lon (str): *optional*, name of the column containing longitudes
            color (int): *optional*, color of the points
            rad (int): *optional*, size of the points
            plot_max (int): *optional*, cap on the number of points to print, sampled randomly if exceeded

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        assert (
            lat in df.columns and lon in df.columns
        ), &#34;lat/lon not found, check dataframe or use lat and lon paramaters&#34;
        df = df.dropna(subset=[lat, lon])

        # apply plot_max cap
        if len(df) &gt; plot_max:
            print(&#34;df has&#34;, len(df), &#34;rows, capping at&#34;, plot_max, &#34;!&#34;)
            df = df.sample(plot_max)
        else:
            df = df

        # add points to the map
        df.apply(
            lambda row: folium.CircleMarker(
                [row[lat], row[lon]],
                radius=rad,
                color=color.value,
                fill=True,
                fill_opacity=1,
                opacity=1,
            ).add_to(self.fmap),
            axis=1,
        )

        self._update_bounds(df[lat], df[lon])
        return self

    def add_geojson(self, obj: json, color: Color = Color.BLUE):
        &#34;&#34;&#34;
        Add a layer with geojson file

        ! geojson polygons must follow the **right-hand rule** (counter-clockwise) !

        ! geojson format uses **(longitude, latitude)** in that order !

        Args:
            obj (json): The geojson object
            color (`reportlib.utils.Color`): *optional*, color of the geojson features

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        geo = folium.GeoJson(
            obj,
            name=&#34;blah&#34;,
            style_function=lambda x: {
                &#34;fillColor&#34;: color.value,
                &#34;color&#34;: color.value,
                &#34;fillOpacity&#34;: 0.1,
            },
        )
        self.fmap.add_child(geo)

        # update bounds
        for f in obj[&#34;features&#34;]:
            coords = np.array(list(geojson.utils.coords(f)))
            self._update_bounds(coords[:, 1], coords[:, 0])
        return self

    def show(self) -&gt; object:
        &#34;&#34;&#34;
        Display the map

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        self.fmap.fit_bounds([self.bounds[&#34;sw&#34;], self.bounds[&#34;ne&#34;]])
        return self.fmap

    def save(self, to: str) -&gt; object:
        &#34;&#34;&#34;
        Save the map in a generated folder

        Args:
            to (str): the new file name, without extension

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        _save_map(self.fmap, to=to)
        return self.fmap


def _create_map(tile: Tile) -&gt; folium.Map:
    return folium.Map(tiles=None).add_child(
        folium.TileLayer(tile.value, name=&#34;base_map&#34;, attr=&#34;atom&#34;)
    )


def _save_map(fmap: folium.Map, to: str) -&gt; None:
    &#34;&#34;&#34;
    Save the map in a generated folder. Note that the process takes ~5 seconds

    Args:
        fmap (folium.Map): the map to save
        to (str): *optional*, the new file name, without extension

    Returns:
        The created folium map
    &#34;&#34;&#34;
    Path(&#34;generated&#34;).mkdir(parents=True, exist_ok=True)
    img_data = fmap._to_png(5)
    img = Image.open(io.BytesIO(img_data))
    img.save(&#34;generated/&#34; + to + &#34;.png&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="reportlib.maps.AtomMap"><code class="flex name class">
<span>class <span class="ident">AtomMap</span></span>
<span>(</span><span>tile: <a title="reportlib.maps.Tile" href="#reportlib.maps.Tile">Tile</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A map object with multiple layers for displaying aois, points, geojson, chloropleth, &hellip;
Choose the base style from <code><a title="reportlib.maps.Tile" href="#reportlib.maps.Tile">Tile</a></code></p>
<h2 id="returns">Returns</h2>
<p>A pandas DataFrame with the query result</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AtomMap:
    &#34;&#34;&#34;
    A map object with multiple layers for displaying aois, points, geojson, chloropleth, ...
    Choose the base style from `reportlib.maps.Tile`

    Returns:
        A pandas DataFrame with the query result
    &#34;&#34;&#34;

    def __init__(self, tile: Tile):
        self.fmap = _create_map(tile)
        self.layers = []
        self.bounds = {&#34;sw&#34;: [], &#34;ne&#34;: []}

        # Init map
        # self.fmap.add_child(folium.LayerControl())

    def _update_bounds(self, lat: list, lon: list) -&gt; object:
        &#34;&#34;&#34;
        Update SW/NE bounds to include new geodata

        Returns:
            self, for chaining
        &#34;&#34;&#34;

        def update_bound(prop, func):
            if self.bounds[prop]:
                self.bounds[prop] = [
                    func(self.bounds[prop][0], func(list(lat))),
                    func(self.bounds[prop][1], func(list(lon))),
                ]
            else:
                self.bounds[prop] = [func(list(lat)), func(list(lon))]

        update_bound(&#34;sw&#34;, min)
        update_bound(&#34;ne&#34;, max)

    def add_aois(self, aois: pd.DataFrame) -&gt; None:
        &#34;&#34;&#34;
        Add a layer with AOIs

        Args:
            aois (DataFrame): The aois to display on the map

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        for index, aoi in aois.iterrows():
            popup = folium.Popup(
                html=f&#34;&lt;b&gt;{aoi[&#39;name&#39;]}&lt;/b&gt;&lt;/br&gt;&#34;,
                show=False,
                sticky=True,
                max_width=500,
            )
            folium.Circle(
                [aoi[&#34;latitude&#34;], aoi[&#34;longitude&#34;]],
                radius=aoi[&#34;radius_km&#34;] * 1000,
                popup=popup,
                fill_color=_Palette.AOI.value,
                color=_Palette.AOI.value,
                opacity=0.3,
            ).add_to(self.fmap)

        self._update_bounds(aois[&#34;latitude&#34;], aois[&#34;longitude&#34;])
        return self  # for serialisation

    # TODO: make this work consistently, edit parameters
    def add_aois_perf(
        self,
        df: pd.DataFrame,
        ctr_color_offset: int = 0,
        markers_size_range: list = [10, 25],
    ):
        &#34;&#34;&#34;
        Add a layer showing performance per AOI, color represents clickthrough rate and size impressions volume

        Args:
            df (DataFrame): The performance data, must have a geohash column to locate the aois
            ctr_color_offset (int): *optional*, by how much to offset the lower bound of the ctr range, will make
            all markers greener
            markers_size_range ([int, int]): *optional*, the range of marker size

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        # Group and compute performance
        perf = df.groupby(&#34;geohash&#34;, as_index=False).agg(
            {&#34;impressions&#34;: &#34;sum&#34;, &#34;clicks&#34;: &#34;sum&#34;, &#34;geohash&#34;: &#34;first&#34;}
        )
        perf[&#34;ctr&#34;] = perf[&#34;clicks&#34;] / perf[&#34;impressions&#34;]
        perf[&#34;ctr_perc&#34;] = perf[&#34;ctr&#34;] * 100

        minctr = perf[&#34;ctr_perc&#34;].min()
        maxctr = perf[&#34;ctr_perc&#34;].max()

        # Print ctr and impressions range
        print(&#34;ctr range for color:&#34;, minctr - ctr_color_offset, &#34;-&#34;, maxctr)
        print(
            &#34;impressions range:&#34;,
            perf[&#34;impressions&#34;].min(),
            &#34;-&#34;,
            perf[&#34;impressions&#34;].max(),
        )

        def linmap(v, mn, mx, mn_to=0, mx_to=1):
            return (v - mn) / (mx - mn) * (mx_to - mn_to) + mn_to

        colormap = cm.LinearColormap(
            colors=[&#34;#F5A331&#34;, &#34;#F5E214&#34;, &#34;#35CC3F&#34;],
            index=[
                minctr - ctr_color_offset,
                (minctr - ctr_color_offset + maxctr) / 2,
                maxctr,
            ],
            vmin=minctr - ctr_color_offset,
            vmax=maxctr,
        )

        # Creates the marker for an AOI
        def marker(geohash, size, intensity):
            return folium.CircleMarker(
                pygeohash.decode(geohash),
                radius=size,
                # color=matplotlib.colors.rgb2hex(colormap(intensity)),
                # fill_color=matplotlib.colors.rgb2hex(colormap(intensity)),
                color=colormap(intensity),
                fill_color=colormap(intensity),
                opacity=1,
                fill_opacity=0.4,
            )

        for _, aoi in perf.iterrows():
            size = linmap(
                aoi[&#34;impressions&#34;],
                perf[&#34;impressions&#34;].min(),
                perf[&#34;impressions&#34;].max(),
                mn_to=markers_size_range[0],
                mx_to=markers_size_range[1],
            )
            intensity = aoi[&#34;ctr_perc&#34;]
            self.fmap.add_child(marker(aoi[&#34;geohash&#34;], size, intensity))

        # Update map boundaries
        aoi_centroids = np.array(
            list(perf[&#34;geohash&#34;].apply(lambda g: pygeohash.decode(g)))
        )
        self._update_bounds(aoi_centroids[:, 0], aoi_centroids[:, 1])
        return self

    def add_points(
        self,
        df: pd.DataFrame,
        lat: str = &#34;latitude&#34;,
        lon: str = &#34;longitude&#34;,
        color: Color = Color.BLUE,
        rad: int = 1,
        plot_max: int = 20000,
    ):
        &#34;&#34;&#34;
        Add a layer showing points from a dataframe

        Args:
            df (DataFrame): The input data
            lat (str): *optional*, name of the column containing latitudes
            lon (str): *optional*, name of the column containing longitudes
            color (int): *optional*, color of the points
            rad (int): *optional*, size of the points
            plot_max (int): *optional*, cap on the number of points to print, sampled randomly if exceeded

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        assert (
            lat in df.columns and lon in df.columns
        ), &#34;lat/lon not found, check dataframe or use lat and lon paramaters&#34;
        df = df.dropna(subset=[lat, lon])

        # apply plot_max cap
        if len(df) &gt; plot_max:
            print(&#34;df has&#34;, len(df), &#34;rows, capping at&#34;, plot_max, &#34;!&#34;)
            df = df.sample(plot_max)
        else:
            df = df

        # add points to the map
        df.apply(
            lambda row: folium.CircleMarker(
                [row[lat], row[lon]],
                radius=rad,
                color=color.value,
                fill=True,
                fill_opacity=1,
                opacity=1,
            ).add_to(self.fmap),
            axis=1,
        )

        self._update_bounds(df[lat], df[lon])
        return self

    def add_geojson(self, obj: json, color: Color = Color.BLUE):
        &#34;&#34;&#34;
        Add a layer with geojson file

        ! geojson polygons must follow the **right-hand rule** (counter-clockwise) !

        ! geojson format uses **(longitude, latitude)** in that order !

        Args:
            obj (json): The geojson object
            color (`reportlib.utils.Color`): *optional*, color of the geojson features

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        geo = folium.GeoJson(
            obj,
            name=&#34;blah&#34;,
            style_function=lambda x: {
                &#34;fillColor&#34;: color.value,
                &#34;color&#34;: color.value,
                &#34;fillOpacity&#34;: 0.1,
            },
        )
        self.fmap.add_child(geo)

        # update bounds
        for f in obj[&#34;features&#34;]:
            coords = np.array(list(geojson.utils.coords(f)))
            self._update_bounds(coords[:, 1], coords[:, 0])
        return self

    def show(self) -&gt; object:
        &#34;&#34;&#34;
        Display the map

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        self.fmap.fit_bounds([self.bounds[&#34;sw&#34;], self.bounds[&#34;ne&#34;]])
        return self.fmap

    def save(self, to: str) -&gt; object:
        &#34;&#34;&#34;
        Save the map in a generated folder

        Args:
            to (str): the new file name, without extension

        Returns:
            self, for chaining
        &#34;&#34;&#34;
        _save_map(self.fmap, to=to)
        return self.fmap</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="reportlib.maps.AtomMap.add_aois"><code class="name flex">
<span>def <span class="ident">add_aois</span></span>(<span>self, aois: pandas.core.frame.DataFrame) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a layer with AOIs</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>aois</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>The aois to display on the map</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>self, for chaining</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_aois(self, aois: pd.DataFrame) -&gt; None:
    &#34;&#34;&#34;
    Add a layer with AOIs

    Args:
        aois (DataFrame): The aois to display on the map

    Returns:
        self, for chaining
    &#34;&#34;&#34;
    for index, aoi in aois.iterrows():
        popup = folium.Popup(
            html=f&#34;&lt;b&gt;{aoi[&#39;name&#39;]}&lt;/b&gt;&lt;/br&gt;&#34;,
            show=False,
            sticky=True,
            max_width=500,
        )
        folium.Circle(
            [aoi[&#34;latitude&#34;], aoi[&#34;longitude&#34;]],
            radius=aoi[&#34;radius_km&#34;] * 1000,
            popup=popup,
            fill_color=_Palette.AOI.value,
            color=_Palette.AOI.value,
            opacity=0.3,
        ).add_to(self.fmap)

    self._update_bounds(aois[&#34;latitude&#34;], aois[&#34;longitude&#34;])
    return self  # for serialisation</code></pre>
</details>
</dd>
<dt id="reportlib.maps.AtomMap.add_aois_perf"><code class="name flex">
<span>def <span class="ident">add_aois_perf</span></span>(<span>self, df: pandas.core.frame.DataFrame, ctr_color_offset: int = 0, markers_size_range: list = [10, 25])</span>
</code></dt>
<dd>
<div class="desc"><p>Add a layer showing performance per AOI, color represents clickthrough rate and size impressions volume</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>The performance data, must have a geohash column to locate the aois</dd>
<dt><strong><code>ctr_color_offset</code></strong> :&ensp;<code>int</code></dt>
<dd><em>optional</em>, by how much to offset the lower bound of the ctr range, will make</dd>
<dt>all markers greener</dt>
<dt><strong><code>markers_size_range</code></strong> :&ensp;<code>[int, int]</code></dt>
<dd><em>optional</em>, the range of marker size</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>self, for chaining</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_aois_perf(
    self,
    df: pd.DataFrame,
    ctr_color_offset: int = 0,
    markers_size_range: list = [10, 25],
):
    &#34;&#34;&#34;
    Add a layer showing performance per AOI, color represents clickthrough rate and size impressions volume

    Args:
        df (DataFrame): The performance data, must have a geohash column to locate the aois
        ctr_color_offset (int): *optional*, by how much to offset the lower bound of the ctr range, will make
        all markers greener
        markers_size_range ([int, int]): *optional*, the range of marker size

    Returns:
        self, for chaining
    &#34;&#34;&#34;
    # Group and compute performance
    perf = df.groupby(&#34;geohash&#34;, as_index=False).agg(
        {&#34;impressions&#34;: &#34;sum&#34;, &#34;clicks&#34;: &#34;sum&#34;, &#34;geohash&#34;: &#34;first&#34;}
    )
    perf[&#34;ctr&#34;] = perf[&#34;clicks&#34;] / perf[&#34;impressions&#34;]
    perf[&#34;ctr_perc&#34;] = perf[&#34;ctr&#34;] * 100

    minctr = perf[&#34;ctr_perc&#34;].min()
    maxctr = perf[&#34;ctr_perc&#34;].max()

    # Print ctr and impressions range
    print(&#34;ctr range for color:&#34;, minctr - ctr_color_offset, &#34;-&#34;, maxctr)
    print(
        &#34;impressions range:&#34;,
        perf[&#34;impressions&#34;].min(),
        &#34;-&#34;,
        perf[&#34;impressions&#34;].max(),
    )

    def linmap(v, mn, mx, mn_to=0, mx_to=1):
        return (v - mn) / (mx - mn) * (mx_to - mn_to) + mn_to

    colormap = cm.LinearColormap(
        colors=[&#34;#F5A331&#34;, &#34;#F5E214&#34;, &#34;#35CC3F&#34;],
        index=[
            minctr - ctr_color_offset,
            (minctr - ctr_color_offset + maxctr) / 2,
            maxctr,
        ],
        vmin=minctr - ctr_color_offset,
        vmax=maxctr,
    )

    # Creates the marker for an AOI
    def marker(geohash, size, intensity):
        return folium.CircleMarker(
            pygeohash.decode(geohash),
            radius=size,
            # color=matplotlib.colors.rgb2hex(colormap(intensity)),
            # fill_color=matplotlib.colors.rgb2hex(colormap(intensity)),
            color=colormap(intensity),
            fill_color=colormap(intensity),
            opacity=1,
            fill_opacity=0.4,
        )

    for _, aoi in perf.iterrows():
        size = linmap(
            aoi[&#34;impressions&#34;],
            perf[&#34;impressions&#34;].min(),
            perf[&#34;impressions&#34;].max(),
            mn_to=markers_size_range[0],
            mx_to=markers_size_range[1],
        )
        intensity = aoi[&#34;ctr_perc&#34;]
        self.fmap.add_child(marker(aoi[&#34;geohash&#34;], size, intensity))

    # Update map boundaries
    aoi_centroids = np.array(
        list(perf[&#34;geohash&#34;].apply(lambda g: pygeohash.decode(g)))
    )
    self._update_bounds(aoi_centroids[:, 0], aoi_centroids[:, 1])
    return self</code></pre>
</details>
</dd>
<dt id="reportlib.maps.AtomMap.add_geojson"><code class="name flex">
<span>def <span class="ident">add_geojson</span></span>(<span>self, obj: <module 'json' from '/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/json/__init__.py'>, color: <a title="reportlib.utils.Color" href="utils.html#reportlib.utils.Color">Color</a> = Color.BLUE)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a layer with geojson file</p>
<p>! geojson polygons must follow the <strong>right-hand rule</strong> (counter-clockwise) !</p>
<p>! geojson format uses <strong>(longitude, latitude)</strong> in that order !</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>json</code></dt>
<dd>The geojson object</dd>
</dl>
<p>color (<code><a title="reportlib.utils.Color" href="utils.html#reportlib.utils.Color">Color</a></code>): <em>optional</em>, color of the geojson features</p>
<h2 id="returns">Returns</h2>
<p>self, for chaining</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_geojson(self, obj: json, color: Color = Color.BLUE):
    &#34;&#34;&#34;
    Add a layer with geojson file

    ! geojson polygons must follow the **right-hand rule** (counter-clockwise) !

    ! geojson format uses **(longitude, latitude)** in that order !

    Args:
        obj (json): The geojson object
        color (`reportlib.utils.Color`): *optional*, color of the geojson features

    Returns:
        self, for chaining
    &#34;&#34;&#34;
    geo = folium.GeoJson(
        obj,
        name=&#34;blah&#34;,
        style_function=lambda x: {
            &#34;fillColor&#34;: color.value,
            &#34;color&#34;: color.value,
            &#34;fillOpacity&#34;: 0.1,
        },
    )
    self.fmap.add_child(geo)

    # update bounds
    for f in obj[&#34;features&#34;]:
        coords = np.array(list(geojson.utils.coords(f)))
        self._update_bounds(coords[:, 1], coords[:, 0])
    return self</code></pre>
</details>
</dd>
<dt id="reportlib.maps.AtomMap.add_points"><code class="name flex">
<span>def <span class="ident">add_points</span></span>(<span>self, df: pandas.core.frame.DataFrame, lat: str = 'latitude', lon: str = 'longitude', color: <a title="reportlib.utils.Color" href="utils.html#reportlib.utils.Color">Color</a> = Color.BLUE, rad: int = 1, plot_max: int = 20000)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a layer showing points from a dataframe</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>The input data</dd>
<dt><strong><code>lat</code></strong> :&ensp;<code>str</code></dt>
<dd><em>optional</em>, name of the column containing latitudes</dd>
<dt><strong><code>lon</code></strong> :&ensp;<code>str</code></dt>
<dd><em>optional</em>, name of the column containing longitudes</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>int</code></dt>
<dd><em>optional</em>, color of the points</dd>
<dt><strong><code>rad</code></strong> :&ensp;<code>int</code></dt>
<dd><em>optional</em>, size of the points</dd>
<dt><strong><code>plot_max</code></strong> :&ensp;<code>int</code></dt>
<dd><em>optional</em>, cap on the number of points to print, sampled randomly if exceeded</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>self, for chaining</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_points(
    self,
    df: pd.DataFrame,
    lat: str = &#34;latitude&#34;,
    lon: str = &#34;longitude&#34;,
    color: Color = Color.BLUE,
    rad: int = 1,
    plot_max: int = 20000,
):
    &#34;&#34;&#34;
    Add a layer showing points from a dataframe

    Args:
        df (DataFrame): The input data
        lat (str): *optional*, name of the column containing latitudes
        lon (str): *optional*, name of the column containing longitudes
        color (int): *optional*, color of the points
        rad (int): *optional*, size of the points
        plot_max (int): *optional*, cap on the number of points to print, sampled randomly if exceeded

    Returns:
        self, for chaining
    &#34;&#34;&#34;
    assert (
        lat in df.columns and lon in df.columns
    ), &#34;lat/lon not found, check dataframe or use lat and lon paramaters&#34;
    df = df.dropna(subset=[lat, lon])

    # apply plot_max cap
    if len(df) &gt; plot_max:
        print(&#34;df has&#34;, len(df), &#34;rows, capping at&#34;, plot_max, &#34;!&#34;)
        df = df.sample(plot_max)
    else:
        df = df

    # add points to the map
    df.apply(
        lambda row: folium.CircleMarker(
            [row[lat], row[lon]],
            radius=rad,
            color=color.value,
            fill=True,
            fill_opacity=1,
            opacity=1,
        ).add_to(self.fmap),
        axis=1,
    )

    self._update_bounds(df[lat], df[lon])
    return self</code></pre>
</details>
</dd>
<dt id="reportlib.maps.AtomMap.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, to: str) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Save the map in a generated folder</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>to</code></strong> :&ensp;<code>str</code></dt>
<dd>the new file name, without extension</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>self, for chaining</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, to: str) -&gt; object:
    &#34;&#34;&#34;
    Save the map in a generated folder

    Args:
        to (str): the new file name, without extension

    Returns:
        self, for chaining
    &#34;&#34;&#34;
    _save_map(self.fmap, to=to)
    return self.fmap</code></pre>
</details>
</dd>
<dt id="reportlib.maps.AtomMap.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Display the map</p>
<h2 id="returns">Returns</h2>
<p>self, for chaining</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self) -&gt; object:
    &#34;&#34;&#34;
    Display the map

    Returns:
        self, for chaining
    &#34;&#34;&#34;
    self.fmap.fit_bounds([self.bounds[&#34;sw&#34;], self.bounds[&#34;ne&#34;]])
    return self.fmap</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="reportlib.maps.Tile"><code class="flex name class">
<span>class <span class="ident">Tile</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tile(Enum):
    TERRAIN = &#34;Stamen Terrain&#34;
    STREETS = &#34;https://api.mapbox.com/styles/v1/gaspardfeuvray/ckpofztgc08ys17mlpwabqxhz/tiles/256/{z}/{x}/{y}@2x?\
access_token=pk.eyJ1IjoiZ2FzcGFyZGZldXZyYXkiLCJhIjoiY2p2YzdhMHZzMWZyMzN5bWo3dTUwY2UxcSJ9.MwgCkS-8xqvM9wjQI-vjgw&#34;
    MONOCHROME = &#34;https://api.mapbox.com/styles/v1/gaspardfeuvray/ckrap3uup0c9717o09tntz4or/tiles/256/{z}/{x}/{y}@2x?\
access_token=pk.eyJ1IjoiZ2FzcGFyZGZldXZyYXkiLCJhIjoiY2p2YzdhMHZzMWZyMzN5bWo3dTUwY2UxcSJ9.MwgCkS-8xqvM9wjQI-vjgw&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="reportlib.maps.Tile.MONOCHROME"><code class="name">var <span class="ident">MONOCHROME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="reportlib.maps.Tile.STREETS"><code class="name">var <span class="ident">STREETS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="reportlib.maps.Tile.TERRAIN"><code class="name">var <span class="ident">TERRAIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="reportlib" href="index.html">reportlib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="reportlib.maps.AtomMap" href="#reportlib.maps.AtomMap">AtomMap</a></code></h4>
<ul class="two-column">
<li><code><a title="reportlib.maps.AtomMap.add_aois" href="#reportlib.maps.AtomMap.add_aois">add_aois</a></code></li>
<li><code><a title="reportlib.maps.AtomMap.add_aois_perf" href="#reportlib.maps.AtomMap.add_aois_perf">add_aois_perf</a></code></li>
<li><code><a title="reportlib.maps.AtomMap.add_geojson" href="#reportlib.maps.AtomMap.add_geojson">add_geojson</a></code></li>
<li><code><a title="reportlib.maps.AtomMap.add_points" href="#reportlib.maps.AtomMap.add_points">add_points</a></code></li>
<li><code><a title="reportlib.maps.AtomMap.save" href="#reportlib.maps.AtomMap.save">save</a></code></li>
<li><code><a title="reportlib.maps.AtomMap.show" href="#reportlib.maps.AtomMap.show">show</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="reportlib.maps.Tile" href="#reportlib.maps.Tile">Tile</a></code></h4>
<ul class="">
<li><code><a title="reportlib.maps.Tile.MONOCHROME" href="#reportlib.maps.Tile.MONOCHROME">MONOCHROME</a></code></li>
<li><code><a title="reportlib.maps.Tile.STREETS" href="#reportlib.maps.Tile.STREETS">STREETS</a></code></li>
<li><code><a title="reportlib.maps.Tile.TERRAIN" href="#reportlib.maps.Tile.TERRAIN">TERRAIN</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>